# set book widths: distrib is between 1-2 inches; assume TRIANGULAR distribution
# NOTE: distribution to be sampled from can be changed to anything we want
a <- 1 # set lower bound of triangular distribution
b <- 2 # set upper bound of triangular distribution
# now sample from triangular distribution: Number of samples = number of books ('Nvols')
books$width <- rtriangle(Nvols, a, b, (a + b)/b )
books$btype <- 'n'
# then set percentage of books to textbook to textbook master copies
# start by picking random sample of books
tbm <- sort(sample(books$book_id, (Nvols * textb_masters), replace = FALSE))
# For each book_id in tbm, set btype = 't', copym = 1, and create copies of
#
for (i in tbm) {
# if the book has not already been set to type 't', proceed
# otherwise ignore and continue
if (books$btype[i] != 't') {
# set btype to 't'
books$btype[i] <- 't'
# set copym to '1'
books$copym[i] <- 1
# get number of copies of textbook via random uniform sample between 1 and 3
tb_copies <- round(runif(1, min = 1, max = 3))
# create copies of textbook directly adjacent to master copy
k <- i + 1
while (k <= Nvols & (k <= i + tb_copies) ) {
books$btype[k] <- 't'
books$dupeof[k] <- books$book_id[i]
# set width of copies to width of master copy
books$width[k] <- books$width[i]
k <- k + 1
}
} # end if
} # end for
View(books)
library(knitr)
# Euler's Method
# initialize data frame to store results
res <- data.frame(x = numeric(5), y = numeric(5))
rownames(res) <- c("t0", "t1", "t2", "t3", "t4")
# initialize x0 and y0
res$x[1] <- 1/2
res$y[1] <- 1
# initialize delta
delta <- 1
# now loop starting at 2 since res[1] contains values of X0 and y0 at t0
for (i in 2:5) {
# dx/dt = x - xy - 3/4*y
res$x[i] <- res$x[(i-1)] + ( res$x[(i-1)] - (res$x[(i-1)] * res$y[(i-1)]) -
(3/4 * res$y[(i-1)] ) ) * delta
# dy/dt = xy - y - 3/4*x
res$y[i] <- res$y[(i-1)] + ( (res$x[(i-1)] * res$y[(i-1)]) -
res$y[(i-1)] - (3/4 * res$x[(i-1)] ) ) * delta
}
res2 <- data.frame(x = numeric(5), y = numeric(5))
rownames(res2) <- c("t0", "t1", "t2", "t3", "t4")
# initialize x0 and y0
res2$x[1] <- 1/2
res2$y[1] <- 1
# initialize delta
delta <- 1
# now loop starting at 2 since res[1] contains values of X0 and y0 at t0
for (i in 2:5) {
# find x*_(n+1). Use variable 'xsnp1' to indicate "x*_n+1"
# equation is: x_n+1 = x_n + (x_n + (x_n * y_n) - 3/4(x_n) ) * delta
xsnp1 <- res2$x[(i-1)] + ( res2$x[(i-1)] - (res2$x[(i-1)] * res2$y[(i-1)]) -
(3/4 * res2$y[(i-1)] ) ) * delta
# find y*_(n+1). Use variable 'ysnp1' to indicate "y*_n+1"
# equation is: y_n+1 = y_n + ( (x_n * y_n) - y_n - 3/4(x_n) ) * delta
ysnp1 <- res2$y[(i-1)] + ( (res2$x[(i-1)] * res2$y[(i-1)]) -
res2$y[(i-1)] - (3/4 * res2$x[(i-1)] ) ) * delta
# calculate x - xy - 3/4*y WITHOUT multiplying by delta OR adding x_n to result
fxn <- res2$x[(i-1)] - (res2$x[(i-1)] * res2$y[(i-1)]) - (3/4 * res2$y[(i-1)] )
# calculate xy - y - 3/4*x WITHOUT multiplying by delta OR adding y_n to result
gyn <- (res2$x[(i-1)] * res2$y[(i-1)]) - res2$y[(i-1)] - (3/4 * res2$x[(i-1)] )
# calculate f(x*_n+1)
fxsnp1 <- xsnp1 - xsnp1*ysnp1 - 0.75*ysnp1
# calculate g(y*_n+1)
gysnp1 <- xsnp1 * ysnp1 - ysnp1 - 0.75*xsnp1
# now calculate approximations for x and y
res2$x[i] <- res2$x[(i-1)] + ( (fxn + fxsnp1) * (delta/2) )
res2$y[i] <- res2$y[(i-1)] + ( (gyn + gysnp1) * (delta/2) )
}
colnames(res1) <- c("Euler-X","Euler-Y")
colnames(res) <- c("Euler-X","Euler-Y")
View(res)
colnames(res2) <- c("Imp_Euler-X","Imp_Euler-Y")
restab <- cbind(res, res2)
kable(restab)
res <- data.frame(x = numeric(5), y = numeric(5))
rownames(res) <- c("t0", "t1", "t2", "t3", "t4")
# initialize x0 and y0
res$x[1] <- 1/2
res$y[1] <- 1
# initialize delta
delta <- 1
# now loop starting at 2 since res[1] contains values of X0 and y0 at t0
for (i in 2:5) {
# dx/dt = x - xy - 3/4*y
res$x[i] <- res$x[(i-1)] + ( res$x[(i-1)] - (res$x[(i-1)] * res$y[(i-1)]) -
(3/4 * res$y[(i-1)] ) ) * delta
# dy/dt = xy - y - 3/4*x
res$y[i] <- res$y[(i-1)] + ( (res$x[(i-1)] * res$y[(i-1)]) -
res$y[(i-1)] - (3/4 * res$x[(i-1)] ) ) * delta
}
res2 <- data.frame(x = numeric(5), y = numeric(5))
rownames(res2) <- c("t0", "t1", "t2", "t3", "t4")
# initialize x0 and y0
res2$x[1] <- 1/2
res2$y[1] <- 1
# initialize delta
delta <- 1
# now loop starting at 2 since res[1] contains values of X0 and y0 at t0
for (i in 2:5) {
# find x*_(n+1). Use variable 'xsnp1' to indicate "x*_n+1"
# equation is: x_n+1 = x_n + (x_n + (x_n * y_n) - 3/4(x_n) ) * delta
xsnp1 <- res2$x[(i-1)] + ( res2$x[(i-1)] - (res2$x[(i-1)] * res2$y[(i-1)]) -
(3/4 * res2$y[(i-1)] ) ) * delta
# find y*_(n+1). Use variable 'ysnp1' to indicate "y*_n+1"
# equation is: y_n+1 = y_n + ( (x_n * y_n) - y_n - 3/4(x_n) ) * delta
ysnp1 <- res2$y[(i-1)] + ( (res2$x[(i-1)] * res2$y[(i-1)]) -
res2$y[(i-1)] - (3/4 * res2$x[(i-1)] ) ) * delta
# calculate x - xy - 3/4*y WITHOUT multiplying by delta OR adding x_n to result
fxn <- res2$x[(i-1)] - (res2$x[(i-1)] * res2$y[(i-1)]) - (3/4 * res2$y[(i-1)] )
# calculate xy - y - 3/4*x WITHOUT multiplying by delta OR adding y_n to result
gyn <- (res2$x[(i-1)] * res2$y[(i-1)]) - res2$y[(i-1)] - (3/4 * res2$x[(i-1)] )
# calculate f(x*_n+1)
fxsnp1 <- xsnp1 - xsnp1*ysnp1 - 0.75*ysnp1
# calculate g(y*_n+1)
gysnp1 <- xsnp1 * ysnp1 - ysnp1 - 0.75*xsnp1
# now calculate approximations for x and y
res2$x[i] <- res2$x[(i-1)] + ( (fxn + fxsnp1) * (delta/2) )
res2$y[i] <- res2$y[(i-1)] + ( (gyn + gysnp1) * (delta/2) )
}
restab <- data.frame(Euler-X = res$x, Euler-Y = res$y,
Imp_Euler-X = res2$x, Imp_Euler-Y = res2$y)
restab <- data.frame("Euler-X" = res$x, "Euler-Y" = res$y,
"Imp_Euler-X" = res2$x, "Imp_Euler-Y" = res2$y)
View(restab)
kable(restab)
sum_cards <- function(hand) {
aces <- FALSE
ace_locs <- numeric()
sum <- 0
# if the hand is only 2 cards, just sum and exit
if (length(hand) == 2) {
sum <- hand[1] + hand[2]
return(sum)
}
# find aces
for (k in 1:length(hand)) {
if(hand[k] == 11) {
aces <- TRUE
ace_locs <- c(ace_locs, k)
}
}
# if no aces were found, sum all items and return
if (aces == FALSE) {
for (i in hand) {
sum <- sum + i
}
return(sum)
}
# otherwise aces were found so first sum items that are NOT aces
not_aces <- subset(hand, !(hand %in% c(11)))
for (i in not_aces) {
sum <- sum + i
}
# if sum of non-aces > 10 all aces must be treated as 1's
if (sum > 10) {
for (i in ace_locs) {
sum <- sum + 1
}
return(sum)
}
# if sum of non-aces <= 9, need to check count of aces.
# If > 1 one can be treated as 11 while other must be treated as 1
if (sum <= 9 & length(ace_locs) > 1) {
sum <- sum + 11
for (i in 1:(length(ace_locs) - 1)) {
sum <- sum + 1
}
return(sum)
}
# if sum of non-aces == 10, need to check count of aces.
# if == 1, then add 11 to sum and exit. if > 1, treat all aces as 1's
if (sum == 10 & length(ace_locs) == 1) {
sum <- sum + 11
return(sum)
} else {
for (i in 1:length(ace_locs)) {
sum <- sum + 1
}
return(sum)
}
}
player_h <- function(p_hand, cards, i, p_stand){
ncards <- length(cards)
stand <- FALSE
while (stand != TRUE) {
# sum current hand
current <- sum_cards(p_hand)
# if card index == number of cards in decks, time to stop
if (i == ncards) {
stand <- TRUE
# else if hand is < p_stand value, take another card
} else if (current < p_stand) {
i <- i + 1
p_hand <- c(p_hand, cards[i])
} else {
stand <- TRUE
}
} # end while stand != TRUE
return(c(current, i))
}
dealer_h <- function(d_hand, cards, i){
ncards <- length(cards)
stand <- FALSE
while (stand != TRUE) {
# sum current hand
current <- sum_cards(d_hand)
# if card index == number of cards in decks, time to stop
if (i == ncards) {
stand <- TRUE
# else if hand is <= 16, take another card
} else if (current <= 16) {
i <- i + 1
d_hand <- c(d_hand, cards[i])
} else {
stand <- TRUE
}
} # end while stand != TRUE
return(c(current, i))
}
play_bj <- function(cards, bet, p_stand){
# initialize the number of cards to be played
ncards <- length(cards)
# initialize index for cards
i <- 0
# initialize winnings accummulator
winnings <- 0
# now loop until all cards used
while (i < ncards) {
# New hand needed: check to see whether at least 4 cards remain unused
if (i <= (ncards - 4)) {
#### Deal 2 cards to player
# increment card index
i <- i + 2
p_hand <- c(cards[i-1], cards[i])
### Deal 2 cards to dealer
# increment card index
i <- i + 2
d_hand <- c(cards[i-1], cards[i])
} else {
# else cards are exhausted so exit
return(winnings)
}
#### logic for player's hand
p_res <- player_h(p_hand, cards, i, p_stand)
# update card index
i <- p_res[2]
# if player didn't go over 21 then apply dealer hand logic
if (p_res[1] <= 21) {
d_res <- dealer_h(d_hand, cards, i)
# update card index
i <- d_res[2]
}
# ---------------------------------------------------------------
# now compare player's hand to dealer's hand to find out who won
# if player hand exceeded 21 subtract 2 from winnings
if (p_res[1] > 21) {
winnings <- winnings - 2
# else if dealer went over 21 dealer has lost so add 2 to winnings
} else if (d_res[1] > 21) {
winnings <- winnings + 2
# else if player hand > dealer hand add 2 to winnings
} else if (p_res[1] > d_res[1]) {
winnings <- winnings + 2
# else if player hand < dealer hand subtract 2 from winnings
} else if (p_res[1] < d_res[1]) {
winnings <- winnings - 2
}
} # end while (i < ncards)
return(winnings)
}
set.seed(123)
# set number of 2-deck sets to play
N <- 12
# set size of bets
bet <- 2
# set hand total for player to stand at
p_stand <- 16
# generate a deck of cards
deck <- rep(c(2:10, 10, 10, 10, 11), 4)
# create a 2 deck set of cards
two_d <- rep(deck,2)
# create a vector to store results of play
res <- data.frame(N = 1:12, winnings = numeric(N))
for (i in 1:N){
# shuffle 2 new decks of cards
s_decks <-sample(two_d,length(two_d), replace = FALSE)
s_decks
# play until 2 decks are exhausted
res$winnings[i] <- play_bj(s_decks, bet, p_stand)
}
# create a table of winnings for each iteration
iteration <- 1:N
kable(data.frame(iteration, res$winnings))
# average the winnings and print to screen
avg_winnings <- mean(res$winnings)
message(paste("Average Winnings per Hand = ", avg_winnings))
iters <- 1000
# create a vector to store results of play
res2 <- data.frame(N = 1:iters, avg_winnings = numeric(iters))
for (k in 1:iters) {
for (i in 1:N){
# shuffle 2 new decks of cards
s_decks <-sample(two_d,length(two_d), replace = FALSE)
s_decks
# play until 2 decks are exhausted
res$winnings[i] <- play_bj(s_decks, bet, p_stand)
} # for i
# save the average the winnings to the results vector
res2$avg_winnings[k] <- mean(res$winnings)
} # for k
summary(res2$avg_winnings)
times <- c(1.88, 0.54, 1.90, 0.15, 0.02,
2.81, 1.50, 0.53, 2.62, 2.67,
3.53, 0.53, 1.80, 0.79, 0.21,
0.80, 0.26, 0.63, 0.36, 2.03,
1.42, 1.28, 0.82, 2.16, 0.05,
0.04, 1.49, 0.66, 2.03, 1.00,
0.39, 0.34, 0.01, 0.10, 1.10,
0.24, 0.26, 0.45, 0.17, 4.29,
0.80, 5.50, 4.91, 0.35, 0.36,
0.90, 1.03, 1.73, 0.38, 0.48)
(lmbda <- 1/mean(times))
k <- 6
p <- 1/k
# initialize vector to store values of endpoints
endpoints <- numeric(k + 1)
# find each endpoint's value
for (i in 0:k) {
endpoints[i+1] <- round( (-1/lmbda) * log(1 - (i * p)), 2)
}
# add the maximum value as the upper bound for the intervals
endpoints[k+1] <- max(times)
endpoints
h1 <- hist(times, breaks = endpoints, xlim = c(0,6), xlab = "Intervals", main = "Histogram of Service Times", probability = TRUE, yaxt='n', col = "yellow")
h1$counts
nvols=1000
nshelves=50
shelf_width=36
textb_masters=0.05
reshelf_thresh=5
seed_val= NULL
sfree_space = 6
Nvols = 1000
library(triangle)
# set max shelf space allowed to be consumed by books at start of simulation
# sfree_space represents the total amount of free space in INCHES
max_shelved <- shelf_width - sfree_space
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
a <- 1 ; b <- 2 # upper/lower bound
books$width <- rtriangle(Nvols, a, b, (a + b)/b )
books$btype <- 'n' # initialize book type to n for non-textbook
# then set percentage of books to textbook to textbook master copies
# start by picking random sample of books
tbm <- sort(sample(books$book_id, (Nvols * textb_masters), replace = FALSE))
for (i in tbm) {
# if the book has not already been set to type 't', proceed
# otherwise ignore and continue
if (books$btype[i] != 't') {
# set btype to 't'
books$btype[i] <- 't'
# set copym to '1'
books$copym[i] <- 1
# get number of copies of textbook via random uniform sample between 1 and 3
tb_copies <- round(runif(1, min = 1, max = 3))
# create copies of textbook directly adjacent to master copy
k <- i + 1
while (k <= Nvols & (k <= i + tb_copies) ) {
books$btype[k] <- 't'
books$dupeof[k] <- books$book_id[i]
# set width of copy to width of master
books$width[k] <- books$width[i]
k <- k + 1
}
}
}
shelves <- data.frame(shelf_id = 1:Nshelves, in_use = numeric(Nshelves),
perc_used = numeric(Nshelves), full=numeric(Nshelves), stringsAsFactors = FALSE)
Nshelves = 50
shelves <- data.frame(shelf_id = 1:Nshelves, in_use = numeric(Nshelves),
perc_used = numeric(Nshelves), full=numeric(Nshelves), stringsAsFactors = FALSE)
k <- 1
# sum book widths to ensure they don't exceed (max shelf width - free_space)
for (i in 1: Nshelves) {
# while space used on shelf < max space consumed by books and book index < Nvols
while ((shelves$in_use[i] + books$width[k]) < max_shelved & (k <= Nvols) ) {
# assign shelf to next book
books$shelf_id[k] <- shelves$shelf_id[i]
# add width of book to total used on current shelf
shelves$in_use[i] <- shelves$in_use[i] + books$width[k]
k <- k + 1
}
}
View(books)
books <- books[which(books$shelf_id != 0),]
# calculate number of deleted books
delbks <- Nvols - nrow(books)
c_out <- sample(books$book_id, (nrow(books) * .10), replace = FALSE)
# For each book_id in c_out, set chkdout = 1 and subtract
# book width from shelf space used for appropriate shelf_id
for (i in c_out) {
# set chkdout flag to 1
books$chkdout[i] <- 1
# subtract width of chkdout book from space in use on its assigned shelf
shelves$in_use[books$shelf_id[i]] <- shelves$in_use[books$shelf_id[i]] - books$width[i]
}
shelves$perc_used = shelves$in_use/shelf_width  # sets perc_used
library(knitr)
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")  # import single_sim...
# set the sequence for the required amounts of free shelf space
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim),
mu_delbks = numeric(df_dim) )
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
del_bks = numeric(100)
df_ind <- 1
# create a data frame to store all simulation results for use outside of the for loop
bxp_df <- data.frame(matrix(, nrow=100, ncol=0))
delbks_df <- data.frame(matrix(, nrow=100, ncol=0))
k = 3
res_list <- single_sim(sfree_space = k)
res_list$iters
res_list$delbks
for(i in 1:100){
res_list <- single_sim(sfree_space = k)
sim_results[i] <- res_list$iters
del_bks[i] <- res_list$delbks
}
# add col containing sim results to boxplot dataframe
bxp_df <- cbind(bxp_df, sim_results)
# set the name of the new col to the number of inches of free space
colnames(bxp_df)[colnames(bxp_df) == 'sim_results'] <- toString(k)
delbks_df <- cbind(delbks_df, del_bks)
# set the name of the new col to the number of inches of free space
colnames(delbks_df)[colnames(delbks_df) == 'del_bks'] <- toString(k)
View(delbks_df)
res_master$mu[df_ind] <- mean(sim_results)
res_master$mdn[df_ind] <- median(sim_results)
res_master$min[df_ind] <- min(sim_results)
res_master$max[df_ind] <- max(sim_results)
res_master$mu_delbks[df_ind] <- mean(del_bks)
View(res_master)
k = 3.5
for(i in 1:100){
res_list <- single_sim(sfree_space = k)
sim_results[i] <- res_list$iters
del_bks[i] <- res_list$delbks
}
bxp_df <- cbind(bxp_df, sim_results)
# set the name of the new col to the number of inches of free space
colnames(bxp_df)[colnames(bxp_df) == 'sim_results'] <- toString(k)
# add col containing del_bks to deleted books dataframe
delbks_df <- cbind(delbks_df, del_bks)
# set the name of the new col to the number of inches of free space
colnames(delbks_df)[colnames(delbks_df) == 'del_bks'] <- toString(k)
View(delbks_df)
res_master$mu[df_ind] <- mean(sim_results)
res_master$mdn[df_ind] <- median(sim_results)
res_master$min[df_ind] <- min(sim_results)
res_master$max[df_ind] <- max(sim_results)
res_master$mu_delbks[df_ind] <- mean(del_bks)
k = 4
View(res_master)
View(res_master)
for(i in 1:100){
res_list <- single_sim(sfree_space = k)
sim_results[i] <- res_list$iters
del_bks[i] <- res_list$delbks
}
bxp_df <- cbind(bxp_df, sim_results)
# set the name of the new col to the number of inches of free space
colnames(bxp_df)[colnames(bxp_df) == 'sim_results'] <- toString(k)
# add col containing del_bks to deleted books dataframe
delbks_df <- cbind(delbks_df, del_bks)
# set the name of the new col to the number of inches of free space
colnames(delbks_df)[colnames(delbks_df) == 'del_bks'] <- toString(k)
View(delbks_df)
View(bxp_df)
k = 6
for(i in 1:100){
res_list <- single_sim(sfree_space = k)
sim_results[i] <- res_list$iters
del_bks[i] <- res_list$delbks
}
bxp_df <- cbind(bxp_df, sim_results)
# set the name of the new col to the number of inches of free space
colnames(bxp_df)[colnames(bxp_df) == 'sim_results'] <- toString(k)
delbks_df <- cbind(delbks_df, del_bks)
# set the name of the new col to the number of inches of free space
colnames(delbks_df)[colnames(delbks_df) == 'del_bks'] <- toString(k)
View(delbks_df)
mean(del_bks)
