summary(sim_results)
xl <- sprintf("Free Space = %1.1f inches", k)
hist(sim_results, breaks = 20, col = 'yellow', xlab = xl)
# store results in master results data frame
res_master$mu[df_ind] <- mean(sim_results)
res_master$mdn[df_ind] <- median(sim_results)
res_master$min[df_ind] <- min(sim_results)
res_master$max[df_ind] <- max(sim_results)
df_ind <- df_ind + 1
}
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")  # import single_sim...
# set the sequence for the required amounts of free shelf space
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
for (k in free_inches) {
print(k)
# run 100 iterations for each free shelf space value
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
# display results for free shelf space = k
sprintf("Free Space = %1.1f inches", k)
summary(sim_results)
xl <- sprintf("Free Space = %1.1f inches", k)
hist(sim_results, breaks = 20, col = 'yellow', xlab = xl)
# store results in master results data frame
res_master$mu[df_ind] <- mean(sim_results)
res_master$mdn[df_ind] <- median(sim_results)
res_master$min[df_ind] <- min(sim_results)
res_master$max[df_ind] <- max(sim_results)
df_ind <- df_ind + 1
}
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
library(knitr)
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")  # import single_sim...
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
for (k in free_inches) {
print(k)
# run 100 iterations for each free shelf space value
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
# display results for free shelf space = k
sprintf("Free Space = %1.1f inches", k)
summary(sim_results)
xl <- sprintf("Free Space = %1.1f inches", k)
hist(sim_results, breaks = 20, col = 'yellow', xlab = xl)
# store results in master results data frame
res_master$mu[df_ind] <- mean(sim_results)
res_master$mdn[df_ind] <- median(sim_results)
res_master$min[df_ind] <- min(sim_results)
res_master$max[df_ind] <- max(sim_results)
df_ind <- df_ind + 1
}
library(triangle)
# set max shelf space allowed to be consumed by books at start of simulation
# sfree_space represents the total amount of free space in INCHES
max_shelved <- shelf_width - sfree_space
# Initialize 'books' data frame
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
Nvols <- 1000
# set total number of shelves
Nshelves <- 50
# set length of shelf in inches
shelf_width <- 36
# set min shelf free space for each shelf as a percentage of total shelf width
sfree_space <- 6
# set max shelf space consumed by books
max_shelved <- shelf_width - sfree_space
# set the percentage of books that are master copies of textbooks
textb_masters <- 0.05
library(triangle)
# set max shelf space allowed to be consumed by books at start of simulation
# sfree_space represents the total amount of free space in INCHES
max_shelved <- shelf_width - sfree_space
# Initialize 'books' data frame
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
sfree_space = 3
library(triangle)
# set max shelf space allowed to be consumed by books at start of simulation
# sfree_space represents the total amount of free space in INCHES
max_shelved <- shelf_width - sfree_space
# Initialize 'books' data frame
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
a <- 1 ; b <- 2 # upper/lower bound
books$width <- rtriangle(Nvols, a, b, (a + b)/b )
books$btype <- 'n' # initialize book type to n for non-textbook
# then set percentage of books to textbook to textbook master copies
# start by picking random sample of books
tbm <- sort(sample(books$book_id, (Nvols * textb_masters), replace = FALSE))
for (i in tbm) {
# if the book has not already been set to type 't', proceed
# otherwise ignore and continue
if (books$btype[i] != 't') {
# set btype to 't'
books$btype[i] <- 't'
# set copym to '1'
books$copym[i] <- 1
# get number of copies of textbook via random uniform sample between 1 and 3
tb_copies <- round(runif(1, min = 1, max = 3))
# create copies of textbook directly adjacent to master copy
k <- i + 1
while (k <= Nvols & (k <= i + tb_copies) ) {
books$btype[k] <- 't'
books$dupeof[k] <- books$book_id[i]
# set width of copy to width of master
books$width[k] <- books$width[i]
k <- k + 1
}
}
}
# Initialize 'shelves' data frame  --> full 0 or 1 flag for whether shelf is full
shelves <- data.frame(shelf_id = 1:Nshelves, in_use = numeric(Nshelves),
perc_used = numeric(Nshelves), full=numeric(Nshelves), stringsAsFactors = FALSE)
k <- 1
# sum book widths to ensure they don't exceed (max shelf width - free_space)
for (i in 1: Nshelves) {
# while space used on shelf < max space consumed by books and book index < Nvols
while ((shelves$in_use[i] + books$width[k]) < max_shelved & (k <= Nvols) ) {
# assign shelf to next book
books$shelf_id[k] <- shelves$shelf_id[i]
# add width of book to total used on current shelf
shelves$in_use[i] <- shelves$in_use[i] + books$width[k]
k <- k + 1
}
}
books <- books[-which(books$shelf_id == 0),]
View(books)
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
a <- 1 ; b <- 2 # upper/lower bound
books$width <- rtriangle(Nvols, a, b, (a + b)/b )
books$btype <- 'n' # initialize book type to n for non-textbook
# then set percentage of books to textbook to textbook master copies
# start by picking random sample of books
tbm <- sort(sample(books$book_id, (Nvols * textb_masters), replace = FALSE))
for (i in tbm) {
# if the book has not already been set to type 't', proceed
# otherwise ignore and continue
if (books$btype[i] != 't') {
# set btype to 't'
books$btype[i] <- 't'
# set copym to '1'
books$copym[i] <- 1
# get number of copies of textbook via random uniform sample between 1 and 3
tb_copies <- round(runif(1, min = 1, max = 3))
# create copies of textbook directly adjacent to master copy
k <- i + 1
while (k <= Nvols & (k <= i + tb_copies) ) {
books$btype[k] <- 't'
books$dupeof[k] <- books$book_id[i]
# set width of copy to width of master
books$width[k] <- books$width[i]
k <- k + 1
}
}
}
shelves <- data.frame(shelf_id = 1:Nshelves, in_use = numeric(Nshelves),
perc_used = numeric(Nshelves), full=numeric(Nshelves), stringsAsFactors = FALSE)
k <- 1
# sum book widths to ensure they don't exceed (max shelf width - free_space)
for (i in 1: Nshelves) {
# while space used on shelf < max space consumed by books and book index < Nvols
while ((shelves$in_use[i] + books$width[k]) < max_shelved & (k <= Nvols) ) {
# assign shelf to next book
books$shelf_id[k] <- shelves$shelf_id[i]
# add width of book to total used on current shelf
shelves$in_use[i] <- shelves$in_use[i] + books$width[k]
k <- k + 1
}
}
which(books$shelf_id == 0)
books <- books[-which(books$shelf_id == 0),]
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
# set book widths: distrib is between 1-2 inches; assume UNIFORM distribution
# now sample from triangular distribution: Number of samples = number of books ('Nvols')
a <- 1 ; b <- 2 # upper/lower bound
books$width <- rtriangle(Nvols, a, b, (a + b)/b )
books$btype <- 'n' # initialize book type to n for non-textbook
tbm <- sort(sample(books$book_id, (Nvols * textb_masters), replace = FALSE))
# For each book_id in tbm, set btype = 't', copym = 1, and create copies of
for (i in tbm) {
# if the book has not already been set to type 't', proceed
# otherwise ignore and continue
if (books$btype[i] != 't') {
# set btype to 't'
books$btype[i] <- 't'
# set copym to '1'
books$copym[i] <- 1
# get number of copies of textbook via random uniform sample between 1 and 3
tb_copies <- round(runif(1, min = 1, max = 3))
# create copies of textbook directly adjacent to master copy
k <- i + 1
while (k <= Nvols & (k <= i + tb_copies) ) {
books$btype[k] <- 't'
books$dupeof[k] <- books$book_id[i]
# set width of copy to width of master
books$width[k] <- books$width[i]
k <- k + 1
}
}
}
# Initialize 'shelves' data frame  --> full 0 or 1 flag for whether shelf is full
shelves <- data.frame(shelf_id = 1:Nshelves, in_use = numeric(Nshelves),
perc_used = numeric(Nshelves), full=numeric(Nshelves), stringsAsFactors = FALSE)
k <- 1
# sum book widths to ensure they don't exceed (max shelf width - free_space)
for (i in 1: Nshelves) {
# while space used on shelf < max space consumed by books and book index < Nvols
while ((shelves$in_use[i] + books$width[k]) < max_shelved & (k <= Nvols) ) {
# assign shelf to next book
books$shelf_id[k] <- shelves$shelf_id[i]
# add width of book to total used on current shelf
shelves$in_use[i] <- shelves$in_use[i] + books$width[k]
k <- k + 1
}
}
books <- books[which(books$shelf_id != 0),]
max_shelved <- shelf_width - 6
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
# set book widths: distrib is between 1-2 inches; assume UNIFORM distribution
# now sample from triangular distribution: Number of samples = number of books ('Nvols')
a <- 1 ; b <- 2 # upper/lower bound
books$width <- rtriangle(Nvols, a, b, (a + b)/b )
books$btype <- 'n' # initialize book type to n for non-textbook
# then set percentage of books to textbook to textbook master copies
# start by picking random sample of books
tbm <- sort(sample(books$book_id, (Nvols * textb_masters), replace = FALSE))
# For each book_id in tbm, set btype = 't', copym = 1, and create copies of
for (i in tbm) {
# if the book has not already been set to type 't', proceed
# otherwise ignore and continue
if (books$btype[i] != 't') {
# set btype to 't'
books$btype[i] <- 't'
# set copym to '1'
books$copym[i] <- 1
# get number of copies of textbook via random uniform sample between 1 and 3
tb_copies <- round(runif(1, min = 1, max = 3))
# create copies of textbook directly adjacent to master copy
k <- i + 1
while (k <= Nvols & (k <= i + tb_copies) ) {
books$btype[k] <- 't'
books$dupeof[k] <- books$book_id[i]
# set width of copy to width of master
books$width[k] <- books$width[i]
k <- k + 1
}
}
}
# Initialize 'shelves' data frame  --> full 0 or 1 flag for whether shelf is full
shelves <- data.frame(shelf_id = 1:Nshelves, in_use = numeric(Nshelves),
perc_used = numeric(Nshelves), full=numeric(Nshelves), stringsAsFactors = FALSE)
k <- 1
# sum book widths to ensure they don't exceed (max shelf width - free_space)
for (i in 1: Nshelves) {
# while space used on shelf < max space consumed by books and book index < Nvols
while ((shelves$in_use[i] + books$width[k]) < max_shelved & (k <= Nvols) ) {
# assign shelf to next book
books$shelf_id[k] <- shelves$shelf_id[i]
# add width of book to total used on current shelf
shelves$in_use[i] <- shelves$in_use[i] + books$width[k]
k <- k + 1
}
}
books <- books[which(books$shelf_id != 0),]
max_shelved <- shelf_width - 6
# Initialize 'books' data frame
books <- data.frame(book_id = 1:Nvols, btype = character(Nvols), copym = numeric(Nvols),
dupeof = numeric(Nvols), shelf_id = numeric(Nvols), width = numeric(Nvols),
chkdout =numeric(Nvols), dedupe = numeric(Nvols), stringsAsFactors = FALSE)
# set book widths: distrib is between 1-2 inches; assume UNIFORM distribution
# now sample from triangular distribution: Number of samples = number of books ('Nvols')
a <- 1 ; b <- 2 # upper/lower bound
books$width <- rtriangle(Nvols, a, b, (a + b)/b )
books$btype <- 'n' # initialize book type to n for non-textbook
# then set percentage of books to textbook to textbook master copies
# start by picking random sample of books
tbm <- sort(sample(books$book_id, (Nvols * textb_masters), replace = FALSE))
# For each book_id in tbm, set btype = 't', copym = 1, and create copies of
for (i in tbm) {
# if the book has not already been set to type 't', proceed
# otherwise ignore and continue
if (books$btype[i] != 't') {
# set btype to 't'
books$btype[i] <- 't'
# set copym to '1'
books$copym[i] <- 1
# get number of copies of textbook via random uniform sample between 1 and 3
tb_copies <- round(runif(1, min = 1, max = 3))
# create copies of textbook directly adjacent to master copy
k <- i + 1
while (k <= Nvols & (k <= i + tb_copies) ) {
books$btype[k] <- 't'
books$dupeof[k] <- books$book_id[i]
# set width of copy to width of master
books$width[k] <- books$width[i]
k <- k + 1
}
}
}
# Initialize 'shelves' data frame  --> full 0 or 1 flag for whether shelf is full
shelves <- data.frame(shelf_id = 1:Nshelves, in_use = numeric(Nshelves),
perc_used = numeric(Nshelves), full=numeric(Nshelves), stringsAsFactors = FALSE)
k <- 1
# sum book widths to ensure they don't exceed (max shelf width - free_space)
for (i in 1: Nshelves) {
# while space used on shelf < max space consumed by books and book index < Nvols
while ((shelves$in_use[i] + books$width[k]) < max_shelved & (k <= Nvols) ) {
# assign shelf to next book
books$shelf_id[k] <- shelves$shelf_id[i]
# add width of book to total used on current shelf
shelves$in_use[i] <- shelves$in_use[i] + books$width[k]
k <- k + 1
}
}
View(books)
books <- books[which(books$shelf_id != 0),]
library(knitr)
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")  # import single_sim...
# set the sequence for the required amounts of free shelf space
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
for (k in free_inches) {
print(k)
# run 100 iterations for each free shelf space value
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
# display results for free shelf space = k
sprintf("Free Space = %1.1f inches", k)
summary(sim_results)
xl <- sprintf("Free Space = %1.1f inches", k)
hist(sim_results, breaks = 20, col = 'yellow', xlab = xl)
# store results in master results data frame
res_master$mu[df_ind] <- mean(sim_results)
res_master$mdn[df_ind] <- median(sim_results)
res_master$min[df_ind] <- min(sim_results)
res_master$max[df_ind] <- max(sim_results)
df_ind <- df_ind + 1
}
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")  # import single_sim...
# set the sequence for the required amounts of free shelf space
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
k = 3
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
print(sprintf("Free Space = %1.1f inches", k))
print(summary(sim_results))
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
print(sprintf("Free Space = %1.1f inches", k))
print(summary(sim_results))
xl <- sprintf("Free Space = %1.1f inches", k)
hist(sim_results, breaks = 20, col = 'yellow', xlab = xl)
library(knitr)
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")  # import single_sim...
# set the sequence for the required amounts of free shelf space
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
k = 3
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
print(sprintf("Free Space = %1.1f inches", k))
print(summary(sim_results))
nvols=1000
nshelves=50
shelf_width=36
sfree_space=3
textb_masters=0.05
reshelf_thresh=5
seed_val= 123
source("setup.R")   # these need to be in the same folder...
source("methods.R")
set.seed(seed_val)   # specify seed
data = setup(nvols, nshelves, shelf_width, sfree_space, textb_masters) #
books = data$books
shelves = data$shelves
View(books)
sample(books$book_id, (length(books) * .10), replace = FALSE)
length(books)
sample(books$book_id, (nrow(books) * .10), replace = FALSE)
set.seed(seed_val)   # specify seed
data = setup(nvols, nshelves, shelf_width, sfree_space, textb_masters) # returns list, need to set to two dfs
#init books and shelves
books = data$books
shelves = data$shelves
View(books)
sample(books$book_id, (nrow(books) * .10), replace = FALSE)
View(books)
c_out <- sample(books$book_id, (nrow(books) * .10), replace = FALSE)
for (i in c_out) {
# set chkdout flag to 1
books$chkdout[i] <- 1
# subtract width of chkdout book from space in use on its assigned shelf
shelves$in_use[books$shelf_id[i]] <- shelves$in_use[books$shelf_id[i]] - books$width[i]
}
View(books)
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
k = 3
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
print(sprintf("Free Space = %1.1f inches", k))
print(summary(sim_results))
xl <- sprintf("Free Space = %1.1f inches", k)
hist(sim_results, breaks = 20, col = 'yellow', xlab = xl)
setwd("c:/users/hammer/Documents/github/Sim_Project")
source("single_sim.R")  # import single_sim...
# set the sequence for the required amounts of free shelf space
free_inches <- seq(3, 6, 0.5)
df_dim <- length(free_inches)
# create data frame to store results of separate simulations for different free shelf space values
res_master <- data.frame(Inches = free_inches, mu = numeric(df_dim), mdn = numeric(df_dim),
min = numeric(df_dim), max = numeric(df_dim))
# create a vector to store results of 100 sims of one free shelf space value
sim_results = numeric(100)
# for each item in the free shelf space sequence, run the full simulation
# and collect results
df_ind <- 1
k = 3
for(i in 1:100){
sim_results[i] <- single_sim(sfree_space = k)
}
print(sprintf("Free Space = %1.1f inches", k))
print(summary(sim_results))
xl <- sprintf("Free Space = %1.1f inches", k)
hist(sim_results, breaks = 20, col = 'yellow', xlab = xl)
